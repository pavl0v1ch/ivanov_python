# Определяется функция-декоратор cache, которая принимает функцию func.
# Цель декоратора сохранить результаты вызовов функции, чтобы избежать повторных вычислений.
def cache(func):
    cached_results = {}  # Создаётся словарь для хранения уже вычисленных результатов.

    # Обёртка wrapper будет вызываться вместо оригинальной функции.
    def wrapper(*args, **kwargs):
        # Формируется ключ для кэширования: позиционные аргументы + отсортированные именованные аргументы.
        key = (args, tuple(sorted(kwargs.items())))

        # Если результат для данного набора аргументов уже есть он возвращается из кэша.
        if key in cached_results:
            return cached_results[key]

        # Если результата нет вызывается оригинальная функция.
        result = func(*args, **kwargs)

        # Полученный результат сохраняется в кэше.
        cached_results[key] = result

        # Возвращается результат вычисления.
        return result

    # Возвращается обёртка, которая заменит оригинальную функцию.
    return wrapper



if __name__ == "__main__":
    # К функции slow_add применяется декоратор cache.
    # Это означает, что повторные вызовы с одинаковыми аргументами не будут вычисляться заново.
    @cache
    def slow_add(a, b):
        print(f"Вычислить сумму {a} + {b}")  # Выводится сообщение при первом вычислении.
        return a + b  # Возвращается сумма двух чисел.


    # Первый вызов: вычисляется сумма и сохраняется в кэше.
    print(slow_add(2, 3))  # Вывод: "Вычислить сумму 2 + 3", затем 5

    # Второй вызов с теми же аргументами: результат берётся из кэша, сообщение не выводится.
    print(slow_add(2, 3))  # Вывод: 5

    # Новый вызов с аргументами через именованный параметр.
    print(slow_add(4, b=1))  # Вывод: "Вычислить сумму 4 + 1", затем 5

    # Повторный вызов: результат берётся из кэша.
    print(slow_add(4, b=1))  # Вывод: 5
