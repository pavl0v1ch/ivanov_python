# Определяется функция flatten, которая принимает список lst.
# Цель — распаковать все вложенные списки и превратить структуру в плоский список.
def flatten(lst):
    i = 0  # Инициализируется индекс для прохода по списку.

    # Цикл продолжается, пока индекс меньше длины списка.
    while i < len(lst):

        # Проверяется, является ли текущий элемент вложенным списком.
        if isinstance(lst[i], list):

            # Вложенный список извлекается методом pop().
            sub = lst.pop(i)

            # Элементы вложенного списка вставляются обратно в основной список.
            # Вставка идёт в обратном порядке, чтобы сохранить исходную последовательность.
            for j in range(len(sub) - 1, -1, -1):
                lst.insert(i, sub[j])

            # Индекс не увеличивается, чтобы обработать новые элементы на той же позиции.
        else:
            i += 1  # Если элемент не список — переход к следующему.


# Определяется функция unique_elements, которая принимает вложенный список.
# Цель — получить список всех уникальных элементов без повторов.
def unique_elements(nested_list):
    flat = nested_list.copy()  # Создаётся копия исходного списка, чтобы не изменять оригинал.
    flatten(flat)  # Список распаковывается до плоской структуры.

    result = []  # Создаётся список для хранения уникальных элементов.

    # Проход по каждому элементу плоского списка.
    # Если элемент ещё не добавлен — он добавляется.
    for item in flat:
        if item not in result:
            result.append(item)

    return result  # Возвращается список уникальных элементов.


if __name__ == "__main__":
    # Создаётся вложенный список с повторяющимися элементами.
    list_a = [1, 2, 3, [4, 3, 1], 5, [6, [7, [10], 8, [9, 2, 3]]]]

    # Вызывается функция unique_elements для получения уникальных значений.
    unique = unique_elements(list_a)


    print(f"Уникальные элементы: {unique}")
