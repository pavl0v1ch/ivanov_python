# Определяется функция type_check, принимающая произвольное количество ожидаемых типов.
# Она возвращает декоратор, который будет проверять типы аргументов при вызове функции.
def type_check(*expected_types):
    # Внутри создаётся функция-декоратор, принимающая целевую функцию func.
    def decorator(func):

        # Обёртка wrapper будет вызываться вместо оригинальной функции.
        # Она проверяет, соответствуют ли типы переданных аргументов ожидаемым.
        def wrapper(*args, **kwargs):

            # Перебираются позиционные аргументы и соответствующие ожидаемые типы.
            for i, (arg, expected) in enumerate(zip(args, expected_types)):

                # Если тип аргумента не соответствует ожидаемому — вызывается исключение TypeError.
                raise_msg = (
                    f"Аргумент #{i + 1} должен быть типа {expected.__name__}, "
                    f"но получен {type(arg).__name__}"
                )
                if not isinstance(arg, expected):
                    raise TypeError(raise_msg)

            # Если все типы корректны — вызывается оригинальная функция.
            return func(*args, **kwargs)

        # Возвращается обёртка, которая заменит оригинальную функцию.
        return wrapper

    # Возвращается сам декоратор, готовый к применению.
    return decorator



if __name__ == "__main__":
    # К функции add применяется декоратор type_check с ожидаемыми типами int и int.
    # Это означает, что оба аргумента должны быть целыми числами.
    @type_check(int, int)
    def add(a, b):
        return a + b  # Функция возвращает сумму двух чисел.


    # Вызывается функция add с аргументами 2 и 3.
    # Так как типы соответствуют ожиданиям результат выводится на экран.
    print(add(2, 3))  # Вывод: 5
    print(add("2", 3))  # вызовет TypeError
